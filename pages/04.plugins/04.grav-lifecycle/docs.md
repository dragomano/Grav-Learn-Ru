---
title: Жизненный цикл Grav
body_classes: lifecycle
taxonomy:
    category: docs
markdown:
    extra: true
---

Часто бывает полезно знать, как работает Grav, чтобы полностью понять, как лучше всего расширить Grav с помощью плагинов. Это жизненный цикл гравитации:

<div class="level level-1" markdown=1>
### index.php
1. Проверка версию PHP, чтобы убедиться, что используется хотя бы версия **5.5.9**
1. Инициализация загрузчика классов
1. Получение экземпляров Grav
    <div class="level level-2" markdown=1>
    ### Grav.php
    1. Экземпляра не существует, поэтому вызываем `load()`
    1. Добавляем `grav`
    1. Инициализируем отладчик и добавляем его в `debugger`
    1. Регистрируем обработчик журналов (`log`)
    1. Регистрируем обработчик ошибок (`error`)
    1. Добавляем `uri`
    1. Добавляем `task`
    1. Добавляем `events`
    1. Добавляем `cache`
    1. Добавляем `session`
    1. Добавляем `plugins`
    1. Добавляем `themes`
    1. Добавляем `twig`
    1. Добавляем `taxonomy`
    1. Добавляем `language`
    1. Добавляем `pages`
    1. Добавляем `assets`
    1. Добавляем `page`
    1. Добавляем `output`
    1. Добавляем `browser`
    1. Добавляем `base_url_absolute`
    1. Добавляем `base_url_relative`
    1. Добавляем `base_url`
    1. Регистрируем обработчик потоков (`stream`)
    1. Регистрируем обработчик конфигураций (`config`)
    </div>
1. вызываем `Grav::process()`
    <div class="level level-2" markdown=1>
    ### Grav.php
    1. Инициализируем конфигурацию
    1. Инициализируем сессию
    1. Инициализируем объект Uri
    1. Инициализируем обработчик ошибок
    1. Инициализируем отладчик
    1. Начинаем буферизацию вывода
    1. Инициализируем часовой пояс
    1. Инициализируем плагины (`plugins`)
    1. Запускаем событие **onPluginsInitialized**
    1. Инициализируем тему
    1. Запускаем событие **onThemeInitialized**
    1. Запускаем событие **onTask[TASK]**
    1. Инициализируем `assets`
    1. Запускаем событие **onAssetsInitialized**
    1. Инициализируем `twig`
        <div class="level level-3" markdown=1>
        ### Twig.php
        1. Задаем пути к шаблонам Twig на основе конфигурации
        1. Обрабатываем языковые шаблоны, если они доступны
        1. Запускаем событие **onTwigTemplatePaths**
        1. Загружаем конфигурацию Twig и цепочку загрузчика
        1. Запускаем событие **onTwigInitialized**
        1. Загружаем расширения Twig
        1. Запускаем событие **onTwigExtensions**
        1. Устанавливаем стандартные переменные Twig (config, uri, taxonomy, assets, browser и т. д.)
        </div>
    1. Инициализируем `pages`
        <div class="level level-3" markdown=1>
        ### Pages.php
        1. Вызываем `buildPages()`
        1. Проверяем наличие кэша
        1. Если **кэш в порядке**, загружаем данные страниц из него
        1. Если **кэш отсутствует**, вызываем `recurse()`
        1. Запускаем событие **onBuildPagesInitialized** in `recurse()`
        1. Если файл `.md` найден:
            <div class="level level-4" markdown=1>
            ### Page.php
            1. Вызываем `init()` для загрузки сведений о файле
            1. Устанавливаем `filePath`, `modified`, `id`
            1. Вызываем `header()` для инициализации переменных заголовка
            1. Вызываем `slug()` для установки слага URL
            1. Вызываем `visible()` для установки видимого состояния
            1. Устанавливаем статус `modularTwig()` в зависимости от того, начинается ли имя папки с `_` или нет
            </div>
        1. Запускаем событие **onPageProcessed**
        1. Если в `папке` найдены потомки `recurse()`
        1. Запускаем событие **onFolderProcessed**
        1. Вызываем `buildRoutes()`
        1. Инициализируем `taxonomy` для всех страниц
        1. Строим таблицу маршрутов (`route`) для быстрого поиска
        </div>
    1. Запускаем событие **onPagesInitialized**
    1. Запускаем событие **onPageInitialized**
    1. Добавляем отладчик CSS/JS в активы
    1. Получаем результат с помощью метода Twig `processSite()`
        <div class="level level-3" markdown=1>
        ### Twig.php
        1. Запускаем событие **onTwigSiteVariables**
        1. Получаем вывод страницы
        1. Запускаем событие **onTwigPageVariables**, also called for each modular subpage
        1. Если страница не найдена или не маршрутизируется, сначала запускаем событие **onPageFallBackUrl** чтобы посмотреть, есть ли у нас запасной вариант для медиа-актива, а затем событие **onPageNotFound**, если нет
        1. Устанавливаем все переменные Twig в объекте Twig
        1. Устанавливаем имя шаблона на основе информации о файле/заголовке/расширении
        1. Вызываем метод `render()`
        1. Возвращаем результирующий HTML
        </div>
    1. Запускаем событие **onOutputGenerated**
    1. Устанавливаем заголовки HTTP
    1. Выводим содержимое буфера
    1. Сбрасываем содержимое буфера на страницу
    1. Запускаем событие **onOutputRendered**
    1. Закрываем соединение с клиентом
    1. Запускаем событие **onShutdown**
    </div>
</div>

Каждый раз, когда у страницы вызывается метод `content()`, происходит следующий жизненный цикл:

<div class="level level-1" markdown="1">
### Page.php
1. Если содержимое **НЕ** кэшировано:
    1. Запускаем событие **onPageContentRaw**
    1. Обрабатываем страницу в соответствии с настройками Markdown и Twig. Запускаем событие **onMarkdownInitialized**
    1. Запускаем событие **onPageContentProcessed**
1. Запускаем событие **onPageContent**
</div>
